Linux 的 Shell 种类众多，常见的有：
·Bourne Shell（/usr/bin/sh或/bin/sh）
·Bourne Again Shell（/bin/bash）
·C Shell（/usr/bin/csh）
·K Shell（/usr/bin/ksh）
·Shell for Root（/sbin/sh）

Bash 也是大多数Linux 系统默认的 Shell

#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。
echo 命令用于向窗口输出文本。
$ 引用

运行 Shell 脚本有两种方法：
## 1、作为可执行程序
将上面的代码保存为 test.sh，并 cd 到相应目录:
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #保存脚本

一定要写成 ./test.sh ：linux 系统会去 PATH 里寻找有没有叫 test.sh 的

## 2、作为解释器参数
这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：
/bin/sh test.sh
/bin/php test.php
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
### 1.变量
定义变量时，变量名不加美元符号$bu;变量名与等号之间不能存在空格
命名规则：
*命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
*中间不能有空格，可以使用下划线（_）。
*不能使用标点符号。
*不能使用bash里的关键字（可用help命令查看保留关键字）。

例：
【显示赋值】
有效的变量名 yun="runoo_w"
【语句赋值】
将 /etc 下目录的文件名循环出来
for file in 'ls /etc'
或
for file in $(ls /etc)

### 2.使用变量
在变量名面前加美元符号$
例：
you="young"
echo $you
echo ${you}  #{}可加可不加


### 3.只读变量
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
#!/bin/bash
myUrl="https://www.google.com"
readonly myUrl

### 4.删除变量
使用 unset 命令可以删除变量
unset variable_name
变量被删除后不能再次使用。unset 命令不能删除只读变量。

#!/bin/sh
myUrl="https://www.runoob.com"
unset myUrl
echo $myUrl
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
### 数据类型（数字、字符串）
1.字符串
字符串可以用单引号，也可以用双引号，也可以不用引号

###### 单引号字符串的限制：
· 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
· 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

###### 双引号：
your_name='runoob'
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str

双引号的优点：
· 双引号里可以有变量
· 双引号里可以出现转义字符

##### 拼接字符串
name="bunn_oo"
str1="you are "$name"!"
str2="that is "${name}"!"
echo $str1 $str2

2.获取字符串的长度
str="abcd"
echo ${#str}

3.提取子字符串
从第二个子字符串开始截取四个字符串：
str="abcdefg"
echo ${str:1:4}


4.查找字符串
查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：
str="abcdfijhko"
echo `expr index "$str" io`
 ` 是反引号

+++++++++++++++++++++++++++++++++++++++++++++++++++++++
#### 数组
bash支持一维数组（不支持多维数组），并且没有限定数组的大小。
数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

1.定义数组
· 用括号来表示数组，数组元素用"空格"符号分割开
数组名=(值1 值2 ... 值n)

· 还可以单独定义数组的各个分量：可以不使用连续的下标，而且下标的范围没有限制。

array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen


2.读取数组
echo value=${array[0]}

使用 @ 符号可以获取数组中的所有元素，例如: echo ${array_name[@]}

3.获取数组的长度
同字符串
length=${#array[@]}   #取得数组元素的个数
length=${#array[n]}   #取得数组单个元素的长度

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

注释：#
多行注释：
:<<EOF
注释内容...
注释内容...
注释内容...
EOF


#### 或者
:<<'
注释内容...
注释内容...
注释内容...
'
#### 或者
:<<!
注释内容...
注释内容...
注释内容...
!

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

##### 传递参数
在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n

##### 特殊字符
参数处理	说明
$#	传递到脚本的参数个数
$*	以一个单字符串显示所有向脚本传递的参数。
如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##### 基本运算符
算数运算符、关系运算符、布尔运算符、字符串运算符、文件测试运算符
#### 1.算数运算符
原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。
反引号 `    算子用空格隔开

val=`expr 3 + 4`
echo $val

运算符	说明	举例
+	加法	`expr $a + $b` 结果为 30。
-	减法	`expr $a - $b` 结果为 -10。
*	乘法	`expr $a \* $b` 结果为  200。
/	除法	`expr $b / $a` 结果为 2。
%	取余	`expr $b % $a` 结果为 0。
=	赋值	a=$b 将把变量 b 的值赋给 a。
==	相等。用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。
!=	不相等。用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。

#### 2.关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

运算符	说明	举例
-eq	检测两个数是否相等，相等返回 true。	[ $a -eq $b ] 返回 false。
-ne	检测两个数是否不相等，不相等返回 true。	[ $a -ne $b ] 返回 true。
-gt	检测左边的数是否大于右边的，如果是，则返回 true。	[ $a -gt $b ] 返回 false。
-lt	检测左边的数是否小于右边的，如果是，则返回 true。	[ $a -lt $b ] 返回 true。
-ge	检测左边的数是否大于等于右边的，如果是，则返回 true。	[ $a -ge $b ] 返回 false。
-le	检测左边的数是否小于等于右边的，如果是，则返回 true。	[ $a -le $b ] 返回 true。



a=10
b=20
if [$a -gt $b]
then
	echo "a is not equal to b"
else
	echo "a is equal to b"
fi


#### 3.布尔运算符

运算符	说明	举例
### !	  非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。
### -o	或运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。
### -a	与运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。



#### 4.逻辑运算符

运算符	说明	举例
&&	逻辑的 AND	[[ $a -lt 100 && $b -gt 100 ]] 返回 false
||	逻辑的 OR	[[ $a -lt 100 || $b -gt 100 ]] 返回 true


#### 5.字符串运算符

运算符	说明	举例
=	   检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
!=	 检测两个字符串是否不相等，不相等返回 true。	[ $a != $b ] 返回 true。
-z	 检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
-n	 检测字符串长度是否不为 0，不为 0 返回 true。	[ -n "$a" ] 返回 true。
$	   检测字符串是否为空，不为空返回 true。	[ $a ] 返回 true。


#### 6.文件测试运算符   用于检测 Unix 文件的各种属性。

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1.显示变量
read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

2.显示换行
echo -e "OK! \n" # -e 开启转义
echo "It is a test"

3.显示不换行
#!/bin/sh
echo -e "OK! \c" # -e 开启转义 \c 不换行
echo "It is a test"

4.显示结果定向至文件
echo "It is a test" > myfile

5.显示命令执行结果
echo `date`

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#### printf

###### printf 命令的语法：
printf  format-string  [arguments...]

参数说明：
format-string: 为格式控制字符串
arguments: 为参数列表。

例：
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543

###### note
1. %s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。
2. - 表示左对齐，没有则表示右对齐
3. %-10s 指一个宽度为 10 个字符，任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。


###### printf 的转义序列

序列	说明
\a	警告字符，通常为ASCII的BEL字符
\b	后退
\c	抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
\f	换页（formfeed）
\n	换行
\r	回车（Carriage return）
\t	水平制表符
\v	垂直制表符
\\	一个字面上的反斜杠字符
\ddd	表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd	表示1到3位的八进制值字符

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
###### test命令
####### 1.数值测试

参数	说明
-eq	等于则为真
-ne	不等于则为真
-gt	大于则为真
-ge	大于等于则为真
-lt	小于则为真
-le	小于等于则为真


####### 2.字符串测试

参数	说明
=	等于则为真
!=	不相等则为真
-z 字符串	字符串的长度为零则为真
-n 字符串	字符串的长度不为零则为真


####### 3.文件测试

参数	说明
-e 文件名	如果文件存在则为真
-r 文件名	如果文件存在且可读则为真
-w 文件名	如果文件存在且可写则为真
-x 文件名	如果文件存在且可执行则为真
-s 文件名	如果文件存在且至少有一个字符则为真
-d 文件名	如果文件存在且为目录则为真
-f 文件名	如果文件存在且为普通文件则为真
-c 文件名	如果文件存在且为字符型特殊文件则为真
-b 文件名	如果文件存在且为块特殊文件则为真

Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##### if循环一行式：
if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi

##### for循环一行式：

for var in item1 item2 ... itemN; do command1; command2… done;

当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。

in列表是可选的，如果不用它，for循环使用命令行的位置参数。

for loop in 1 2 3 4 
do
   echo "it is $loop"
done
-------------------------
for loop in it is a string 
do
   echo "it is $loop"
done


##### while循环

while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：

while condition
do
    command
done

----------------
a=1
while (($a<=5))
do
	echo $a
	let "a++"
done

 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量

####### while循环可用于读取键盘信息。

##### 无线循环
while :
do
    command
done

或者

while true
do
    command
done

或者

for (( ; ; ))


##### until 循环

until 循环执行一系列命令直至条件为 true 时停止。
until 循环与 while 循环在处理方式上刚好相反。
一般 while 循环优于 until 循环


until condition
do
    command
done

condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。



##### case ... esac多选择语句

是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。

可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。

case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac


取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac

##### 跳出循环
break / continue

break命令允许跳出所有循环（终止执行后面的所有循环）。

#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break
        ;;
    esac
done


continue命令仅仅跳出当前循环。
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
##### 自定义函数

定义格式：

[ function ] funname [()]

{

    action;

    [return int;]

}

说明：
1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255


例：定义函数并调用
#!/bin/bash

demoFun(){
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"



##### 传递参数
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73

####### 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。

几个特殊字符用来处理参数：

参数处理	说明
$#	传递到脚本或函数的参数个数
$*	以一个单字符串显示所有向脚本传递的参数
$$	脚本运行的当前进程ID号
$!	后台运行的最后一个进程的ID号
$@	与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-	显示Shell使用的当前选项，与set命令功能相同。
$?	显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

##### 输入输出重定向


重定向命令列表如下：
命令	说明
command > file	将输出重定向到 file。
command < file	将输入重定向到 file。
command >> file	将输出以追加的方式重定向到 file。
n > file	将文件描述符为 n 的文件重定向到 file。
n >> file	将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m	将输出文件 m 和 n 合并。
n <& m	将输入文件 m 和 n 合并。
<< tag	将开始标记 tag 和结束标记 tag 之间的内容作为输入。


=============输出重定向=========
输出重定向会覆盖文件内容
如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾

$ who > users     将命令的完整的输出重定向在用户文件中(users)
执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。

$ cat users   用 cat 命令查看文件内容


======输入重定向========



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


##### 文件包含

. filename   # 注意点号(.)和文件名中间有一空格

或

source filename


例：
test1.sh 代码如下：

#!/bin/bash
url="http://www.runoob.com"


test2.sh 代码如下：

#!/bin/bash
#使用 . 号来引用test1.sh 文件
. ./test1.sh
#或者使用以下包含文件代码
# source ./test1.sh
echo "菜鸟教程官网地址：$url"












